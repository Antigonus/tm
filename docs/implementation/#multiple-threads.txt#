
--------------------------------------------------------------------------------
Issue

  Suppose n machines are sharing a tape, and an entanglement list.

  Then it will be the case that the entanglement list has n entries, as it will have exactly
  one reference for each of the n machines.

  Now suppose that deallocate is called on one of the entangled machines.  We want to check
  for collisions with the other entangled machines, then

  1.
    If we are not in a multithreaded environment, then all the other
    machines will remain stationary while we check for collisions.
    Such a check will get an accurate result.

  2.
    If we do not implement locks, and we are in a multithreaded environment,
    either a true multithreaded environment, or an emulated one, then
    the other machines might move during the collision check, and we might
    get the wrong answer.

  It follows from point 2 above that to support use of containers that share tapes over
  multiple threads, we will require some sort of locking so that a machine can not move and
  become a collision after it was checked and found not to be colliding.


--------------------------------------------------------------------------------
Interface
..using Bordeaux threads

1. An entanglement object, shared among entangled machines

   Has data:
   1. entanglement-lock
   2. counter-lock ; counts heads in flight
   3. counter-condition
   4. solo-tm of references to the entangled machines

   Has these methods:
   1. use-entanglement
   2. use-head-motion

  use-entanglements accepts a work function.  It runs the function.  The function may use
  the entanglements list in a coherent manner.

  use-head-motion accepts work function. It runs the function.  The function may move the
  tape head without causing entanglement accounting to become incoherent.

--------------------------------------------------------------------------------
Implementation

  Note that locks are released during condition-wait.

  use-entanglements:

    acquire entanglement-lock
      acquire counter-lock
        if counter != 0 (condition-wait counter-condition counter-lock)
        do work 
      release counter-lock
    release entanglement-lock

  use-head-motion:

    acquire entanglement-lock
      acquire counter-lock
        increment counter
      release counter-lock
    release entanglement object lock 
    do work
    acquire counter-lock
      decrement counter
      if counter == 0 (condition-notify counter-condition)
    release counter-lock


Notes:

  The two chief reasons for employing multiple threaded execution are independence and
  performance.  An example of independence is when we have a pipe, and the writer
  of the pipe is a separate program from the reader of the pipe.  Performance is
  when we use multiple threads to get more work done per cycle.

  The entanglements-lock plays two roles.  Firstly, it is used to prevent head motion
  operations from running while the entanglements list is being checked for collisions.
  This is necessary for maintaining coherency.  Secondly, it serializes entanglement
  operations to assure that the tm-solo restrictions are met on the list of entangled
  machines.  This approach is overly restrictive in that motion operations will also be
  blocked when they need not be, for example when the entanglements list is used for
  updating leftmost cells (the leftmost is the leftmost independent of the head location).
  Also entanglement use functions are unnecessarily serialized when no destructive
  operations are involved.

  the use-head-motion blocks on the entanglement-lock to assure that entanglement
  object operations will be coherent.  
  

Examples:

  1. We come into a function that will use the entanglements object. We acquire the
   entanglement-lock.  The head-motion counter is zero, so we continue and do
   work. Meanwhile one or more threads enter a head motion function, but each blocks on
   the entanglement-lock.  Then the entanglements use operation comes to an end, so we
   release the entanglement-lock and the one or more head motion functions continue.

  2. We come into a head motion function.  We acquire the entanglement-object lock.  We
  increment the head motion counter. we release the entanglements lock, and do work. Then
  an entanglements-use function starts, but it waits because the counter is not zero.
  We then finish our work, decrement the counter, and upon noticing the counter is
  now zero, we notify the entanglement object use function that it can continue.  We
  release the lock.

  3. A whole bunch of threads are running head motion functions.  We enter an
  entanglement use function and get the lock.  No new head motion functions can run
  because we have entanglements lock. We wait for the currently running head
  motion functions to finish.  When the last head motion function finishes it
  sees the counter is zero, and notifies the entanglement use function that it
  may continue.

  4. We enter an entanglement use function, but fail to get the lock.  We block until
  getting it.  While we are blocking no head motion functions can run, because
  entanglement-use is set, so they queue up.  While we are waiting another entanglement use
  function desires to run, so it queues up too.  Eventually we acquire the lock, do
  our work etc.




