<!DOCTYPE HTML>
<html>
<head>
	<title>TM - Issues</title>
        <link rel="stylesheet" href="style.css" type="text/css" />
        <meta lang="en-US"/>
	<meta name="created" content="2016-03-28T11:07:52.454883632"/>

</head>

<body>
  <header>
    <ul class="nav">
      <li class="nav"><a href="index.html">Top</a></li>
      <li class="nav"><a href="toc.html">Table of Contents</a></li>
    </ul>
    <div class="center">
      <ul class="pagination">
        <li><a href="introduction.html">1</a></li>
        <li><a href="unicode.html">2</a></li>
        <li><a href="nomenclature.html">3</a></li>
        <li><a href="list-making.html">4</a></li>
        <li><a href="stepping.html">5</a></li>
        <li><a href="working.html">6</a></li>
        <li><a href="spaces.html">7</a></li>
        <li><a href="generators.html">8</a></li>
        <li><a href="transforms.html">9</a></li>
        <li><a href="issues.html" class="active">10</a></li>
        <li><a href="dictionary/Package-TM-list.html">11</a></li>
      </ul>
    </div>
  </header>

  <article>
      <section>
        <h1> Issues </h1>

        <p>
          Changes to the head location or the contents of cell on the tape are said to
          be <i>stateful</i> changes.  Changes to the number of cells on the tape are said
          to be <i>structural</i> changes.  The two ways to change structure are through
          allocation and deallocation.  Some tape machines can not go through structural
          changes, for example those that mount fixed arrays.

        <p>
          When there are no structural changes, then, in theory it is not possible to
          break a tape machine.  What we mean by break, is that it is not possible when
          using calls to the interface to make it such that a tape machine does not
          respond in the manner defined by the interface functions. I say in theory,
          because this is the intention of the architectural design.  It is possible that
          this intention has not been translated into a perfect design or perfect
          implementation.

        <p>
          In a second scenario, one with a single head on a tape, i.e. when the function
          #'dup has never been called, in theory it is also not possible to break a tape
          machine - even in the presence of structure changing operations.  Allocate and
          Deallocate have been carefully designed so as to achieve this property.

        <p>
          Even in the presence of multiple heads and structural changes, tape machines still
          can not be broken if those operations are used while checking for and avoiding
          hazards.  One example of this is the implementation of <i>tm-interval</i>.  So
          what are the hazards?

        <h2> Deletion of the Cell the Head is on Hazard</h2>                  

        <p>
          So now we have the case where #'dup has been called, and structural changes are
          allowed.  One of the duplicates could be used used to deallocate a cell
          indicated by the head of the other duplicate.  This is very easy to set up.
          Just dup a tape machine, step one of the duplicates, and call deallocate on the
          other.  The behavior of a tape machine with an indicated cell that has been
          deallocated is undefined, for good reason, as we are not sure what will happen,
          but are fairly sure it will often be bad.

        <p>
          We rely on the programmer to maintain a contract with us that he will never
          write code that leaves a tape machine head dangling in such a manner.  We did
          consider a programmed solution, but it does not seem right for Lisp, it is
          discussed in the next section.

        <h2> Fix for Multiple Heads and Structure Change Hazard <br>
          ... and why it was not implemented
        </h2>


        <p>
          The fix is to add a third slot to the tape machine class. In this third
          slot we have list or references to tape machines that have a head on the
          tape.  Then upon applying a destructive change to the tape, we check the
          head locations for all the listeners, and if there is a conflict we
          take a conflict continuation path.

        <p>
          I did not implement this, at least on this version of the library, because
          of the manner in which memory allocation is done in Lisp.  In Lisp when
          we are done using something, the garbage collector sees that, and the unused
          stuff goes away.  So, if we put a tape machine on a listener list, it
          always looks used, and it never goes away. 
          
        <p>
          We can introduce a destructor that must be called to explicitly release a tape
          machine, but that would go against conventional programming practices in Lisp.

        <p>
          There appears to be some tricky ways around all this, but those are too involved
          to implement at the current level of developer engagement ;-) .. i.e. it looks
          like too much work for me at this time.

      <h2> Allocation on Arrays </h2>

        <p>
          In Lisp we have two types of arrays to think about, the extendable array
          and the fixed array. 

        <p>
          Allocation requires creating a new cell to the right of the current
          cell. If we are at the rightmost cell, then we can move the fill pointer
          of the extendable array, and we have an allocation.  Conversely, if
          we are one away from rightmost, we can deallocate by moving the fill
          pointer back. 
          
        <p>
          For a fixed array, we do not have a fill pointer, so we will instantly just
          take <i>cont-no-alloc</i>.

        <p>
          When the head is in the middle of the array, allocation can be accomplished
          by moving all the objects found to the right of the head to the right,
          and then bumping up the fill pointer.  We refer to this technique as
          <i>emulating allocation</i>.

        <p>
          If there are multiple heads on the tape we run into a problem with
          emulating allocation.  When we move the objects right as part of an
          operation on one tape machine, the object in the cell the head is
          on changes for all other tape machines with heads further to the right.

        <p>
          The problem with emulating allocation on arrays when there are multiple
          tape heads can also be fixed with a listener list, as discussed above.

        <p> But why perform emulated allocation when there is a move function, #'m that is
          more suited for manipulating data in arrays?  By definition when objects are
          moved right with the move function, the object in a particular cell to the right
          will change.  Also by definition, objects that fall off the end are just thrown
          away, so #'m even works on fixed length arrays. (If the programmer wants to keep
          objects that would fall of the end, he or she can copy them first.  We do not
          need an explicit copy function, as write, #'w, already accepts an initialization
          object, and #'w* accepts an initialization machine, and thus is a copy
          function.)

      <h2> Data Movement Over Lists </h2>

        <p>
          When only one tape head is involved, data movement can be efficiently
          emulated over a list by allocating a new cell to the right, and deallocating
          rightmost.  However, when there are multiple heads involved, we run
          into the problem that the objects in the cells under those heads does
          not change, which is an specified behavior for #'m.

        <p>
          When the mounted list is singly linked, employing a listener list will not help
          with the problem of multiple heads, because to make it look like data moved
          right, the other machine heads would have to step left, which is not implemented.

      <h2> Design Decision about the Listener List </h2>

        <p>
          Due to the considerations explained above, for this version of the tape machine
          library it seems to make most sense to use tape machine type specific functions
          for making cells available for use, and analogous operations, with the exception
          of allowing rightmost allocation on extendable arrays.  The type of the tape can
          be checked by unmounting and then using typeof or typep.

        <p>
          In the presence of multiple tape heads and destructive operations, we suggest
          that the programmer provide at least a sketch of a proof as to why hazards will
          not occur, or that that a tool is used to attempt to check this automatically
          (it may not be possible in general).  Also note, the tape machine library did
          not create container use hazards, rather it is only formalizing their
          description.

      <h2> Multithreaded, Multiple Heads, and Structural Changes </h2>

        <p>
          The above remarks apply.  In addition structural changes typically will have
          to be thread mutually exclusive.


    </section>
  </article>

</body>
</html>
