<!DOCTYPE HTML>
<html>
<head>
	<title>TM - Stepping</title>
        <link rel="stylesheet" href="style.css" type="text/css" />
        <meta lang="en-US"/>
	<meta name="created" content="2016-03-28T11:07:52.454883632"/>

</head>

<body>
  <header>
    <ul class="nav">
      <li class="nav"><a href="index.html">Top</a></li>
      <li class="nav"><a href="toc.html">Table of Contents</a></li>
    </ul>
    <div class="center">
      <ul class="pagination">
        <li><a href="introduction.html">1</a></li>
        <li><a href="unicode.html">2</a></li>
        <li><a href="nomenclature.html">3</a></li>
        <li><a href="list-making.html">4</a></li>
        <li><a href="stepping.html" class="active">5</a></li>
        <li><a href="working.html">6</a></li>
        <li><a href="spaces.html">7</a></li>
        <li><a href="generators.html">8</a></li>
        <li><a href="transforms.html">9</a></li>
        <li><a href="issues.html">10</a></li>
        <li><a href="dictionary/Package-TM-list.html">11</a></li>
      </ul>
    </div>
  </header>

  <article>
      <section>
        <h1> Stepping </h1>

        <p>
          Here is a simple program that makes use of a tape machine.

          <pre><code>
              (let(
                    (a-tape-machine (mount {1 2 3}))
                    )
                (print (r a-tape-machine))
                (s a-tape-machine)
                (print (r a-tape-machine))
                (s a-tape-machine)
                (print (r a-tape-machine))
                (s a-tape-machine)
                )
          </code></pre>

        <p>
          When run it produces:

          <pre><sample>
              1 
              2 
              3 
              NIL
          </sample></pre>

        <p>
          #'mount accepts a sequence and returns a tape machine.  Different sequences
          will result in different types of tape machines, but that is typically of
          little importance, as all tape machine share the same function interface.
          After a sequence is mounted, the tape machine head will be on leftmost.

        <p>
          #'r is a function that accepts a tape machine and returns the indicated object.
          #'w does the inverse operation.  It accepts a tape machine and an object, and
          then writes the object into the indicated cell.  Hence, the first <code>(print
          (r a-tape-machine))</code> will print the number 1.

        <p>
          #'s moves the tape head to the right neighbor cell, so the second <code>(print
            (r a-tape-machine))</code> will print the number 2. Etc.  Note we do not
            provide any continuation function arguments to #'s.  They are optional, and
            the defaults are <code>(be t)</code> and <code>(be ∅)</code>.  That is why at
            the final step, when stepping fails, the program returns NIL.  (The printer is
            not aware of our alias ∅, so it prints NIL.)

        <p>
          Now it would be more convenient to use a loop to implement this logic.

          <pre><code>
              (let(
                    (a-tape-machine (mount {1 2 3}))
                    )
                (⟳ (λ(cont-loop cont-return)
                      (print (r a-tape-machine))
                      (s a-tape-machine cont-loop cont-return)
                      )))
          </code></pre>

        <p>
          And this time the output is:

          <pre><sample>
              1 
              2 
              3 
              T
          </sample></pre>

        <p>
          In this case the return value comes from loop, and the loop returns T.  In fact
          the default function for the cont-rightmost parameter never runs, instead the
          provided function for <i>cont-return</i> runs.

        <p>
          In general we follow this paradigm, first doing some work, then stepping.  In
          the loop these two operations are performed repeatedly until stepping fails.  Be
          careful when writing TM programs to not be anxious to apply loop operators.
          Instead, prefer to implement functions that do one unit of work, and move the
          looping to a higher level. If you are concerned about the function call overhead
          then declare it as an inline function. 

        <p>
          Notice that unlike the standard loops in Lisp where the location information
          used in iteration is gone after we exit from the loop, we still have the tape
          machine after the loop exits.  We could, for example, cue-leftmost, and process
          the same data again.  When multiple tape machines are involved in a loop, we
          will know where each left off when the loop terminates.  We have a special form
          for looping multiple machines in a transactional manner (i.e they all step or
          none do), it is called <i>⟳-together</i>.

        <p>
          Another kind of loop is the quantifier.  All the looping forms are
          defined in the file src-1/tm-quantifiers.  We provide the two main
          quantifiers, #'∃  and #'∀, and the complement variations of them.

        <p>
          The existence quantifier, #'∃ accepts a tape machine and a predicate.  It
          starts at leftmost, then steps right cell by cell until the predicate
          is true.  Should the end of the tape be reached, then the quantification
          is false.  Because some work can be done inside the predicate function,
          this is the same thing as loop until.  
         
        <p>
          The universal quantifier, #'∀ also accepts a tape machine and a predicate.  It
          starts at leftmost, and steps right for as long as the predicate remains true.
          This is the same thing as a while loop.  This quantifier returns false should an
          exception be found, or returns true should the end of the tape be reached.

        <p>
          When called this function will return true:

<pre><code>
  (defun test-∃-0 ()
    (let*(
           (y {1 2 {3 4} 5})
           (ytm (mount y))
           )
      (∃ ytm (λ(tm)(and (typep (r tm) 'cons) (eql 3 (car (r tm))))))
      (equal (r ytm) '(3 4))
      ))
</code></pre>

    </section>
  </article>

</body>
</html>
