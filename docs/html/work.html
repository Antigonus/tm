<!DOCTYPE HTML>
<html>
<head>
	<title>TM - Work</title>
        <link rel="stylesheet" href="style.css" type="text/css" />
        <meta lang="en-US"/>
	<meta name="created" content="2016-03-28T11:07:52.454883632"/>

</head>

<body>
  <header>
    <ul class="nav">
      <li class="nav"><a href="#home">Top</a></li>
      <li class="nav"><a href="#home">Table of Contents</a></li>
    </ul>
    <div class="center">
      <ul class="pagination">
        <li><a href="#">1</a></li>
        <li><a href="#" class="active">2</a></li>
        <li><a href="#">3</a></li>
        <li><a href="#">4</a></li>
        <li><a href="#">5</a></li>
        <li><a href="#">6</a></li>
        <li><a href="#">7</a></li>
      </ul>
    </div>
  </header>

  <article>
      <section>
        <h1> Doing Work </h1>

        

        <p>
          Here is a simple program that creates a fresh list by squaring
          the items in a source list.

          <pre><code>
             (let(
                  (source (mount {1 2 3}))
                  (destination (tm-mk 'tm-list))
                  )
               (⟳ (λ(cont-loop cont-return)
                    (as destination (expt (r source) 2))
                    (s source cont-loop cont-return)
                    ))
               (unmount destination)
             )
          </code></pre>

          When running this it produces:

          <pre><sample>
              (LIST 1 4 9)              
          </sample></pre>

        <p>
          The function #'tm-mk is a more primitive form of #'mount.  Where as
          mount accepts a sequence, and returns the most appropriate type of
          tape machine, #'tm-mk requires the user to specify the tape machine
          type.  It takes an optional initialization parameter.  The initialization
          parameter can be of any type that is supported by the #'tm-mk
          methods.  If no initialization parameter is supplied, as is the case
          here, a single cell tape machine is created, and that cell is initialized
          with the the type of the type.  Here we make a tape machine that that
          uses a list as a tape, so the initial cell is set to 'list.

        <p>
          The function #'a allocates a new cell just to the right of the head, and
          it initializes that cell with the object specified in the call. In this
          example this is the square of the number specified on the source.  #'as
          is a compound command.  The compound contains allocate and step.  So in
          our example here, after the call to #'as the head will be on the newly
          allocated cell. We can repeat the call to #'as and grow the length of the
          tape. The nice part about this approach, as unlike using the conventional
          cons cell at the front, the element order in the destination list will be
          the same as the element order in the source list.
          
        <p>
          #'unmount does is the inverse of #'mount.  It returns the tape, and as
          it is the last statement in our code, it provides the return value.
          Should this output then be evaluated, we will have a list.  Alternatively
          we could have returned  <code>(cdr (unmount destination))</code> and
          the head of the returned list would be the number 1.

        <p>
          We call a program that accepts input from a source tape machine,
          and then produces output on a destination tape machine, and does so
          one step at a time, a <i>worker</i>.  The worker in this example is
          <i>(as destination (expt (r source) 2))</i>.  The amount of work
          done upon each call to the worker is "one unit of work".

        <p>
          Notice, that each time we call a worker its source and destination
          machine arguments are the same.  These can be curried away.  Or
          put another way, we might think of a worker as being connected into
          the program rather than as accepting arguments that evaluate to values
          upon each call.  We provide a macro for that returns a worker
          function.  This macro does the currying, or the connecting, whichever
          way you want to think about it.

          <pre><code>
              (defmacro def-worker (name src dst state conts &body body) ...)

              src := tape-machine-name | (tape-machine-name ..) | ()
              dst := tape-machine-name | (tape-machine-name ..) | ()
              state := symbol | (symbol ..) | ()
              conts := contination-name | (continuation-name ..) | ()

              tape-machine-name := symbol (evaluates to a tape machine)
              contination-name := symbol  (evaluates to a continuation function)

          </code></pre>

          <i>name</i> is a symbol, and is the name of the resulting connection
          function.  The connection funciton will be used to get a worker
          function, and the worker function takes no arguments.

          <i>src</i> is either a symbol that will evaluate to a
          source tape machine, a list of such symbols, or an empty set of
          parentheses, ie. an empty list.  When <i>src</i> is a symbol, the connection
          function will accept a single tape machine as a first argument.  When
          <i>src</i> is specified as a list, then the connector expects a list of tape
          machines as a first argument.  The list will be deconstructed, so the programmer
          may use &optional, &rest, and other such parameter keywords when specifying the
          list of symbols.  When <i>src</i> is an empty set of parentheses, the connection
          function does not have a src parameter, it is skipped.  The other parameters are
          handled in an analogous way.  See src-2/worker.lisp for the macro definition.

          Here is an example of defining a worker.

          <pre><code>
            (def-worker counter tm-src () boxed-counter ()
              (s tm-src
                (λ()(incf (unbox boxed-counter)) t)
                (be ∅)
                ))
          </pre></code>

        <p>
          Here the connection function is called <i>counter</i>.  The connection
          function will take a single source tape machine, it does not accept
          any destination tape machines.  It accepts a single state variable.

        <p>
          The purpose of counter is to increment a count each time it is called.  We might
          use this to get the length of the source tape, though, we already provide a
          length function in the library. Albeit, it is a simple example.  The count is
          passed in as a state variable.  We require that all variables be passed by
          reference, which is the default in Lisp for complex objects, but alas, not
          for integers.  Hence we are going to pass the counter "in a box".  Box is
          defined in src-0/functions.lisp.



          <pre><code>
            (defun test-worker-1 ()
              (let(
                    (tm (mount {0 1 2 3}))
                    (cnt 0)
                    )
                (labels(
                      (worker () (counter tm (box cnt)))
                      )
                  (∧
                    (= cnt 0)
                    (worker)
                    (= cnt 1)
                    (worker)
                    (= cnt 2)
                    (worker)
                    (= cnt 3)
                    (¬ (worker))
                    )
                  )))

          </pre></code>

        <p>
          The function test-worker-1 will return true.  Note the use of the
          unicode synonym for not, ¬, in the last line of the conjunction.
          State variables must be passed by reference.  Lisp passes tape
          machines by reference, but integers are passed by value, hence
          we put the count "in a box", and pass the box.  Box is defined
          in src-o/functions.lisp.
         
        <p>
          So in this example we 

  <i>dst</i> has
          the same form.


    </section>
  </article>

</body>
</html>
