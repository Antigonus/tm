<!DOCTYPE HTML>
<html>
<head>
	<title>TM - More For Lists</title>
        <link rel="stylesheet" href="style.css" type="text/css" />
        <meta lang="en-US"/>
	<meta name="created" content="2016-03-28T11:07:52.454883632"/>

</head>

<body>
  <header>
    <ul class="nav">
      <li class="nav"><a href="#home">Top</a></li>
      <li class="nav"><a href="#home">Table of Contents</a></li>
    </ul>
    <div class="center">
      <ul class="pagination">
        <li><a href="#">1</a></li>
        <li><a href="#" class="active">2</a></li>
        <li><a href="#">3</a></li>
        <li><a href="#">4</a></li>
        <li><a href="#">5</a></li>
        <li><a href="#">6</a></li>
        <li><a href="#">7</a></li>
      </ul>
    </div>
  </header>

  <article>
      <section>
        <h1> New Lists Making Functions</h1>

        <p>
          Because of our method of continuations, and our adoption of workers, we have
          ended up with some extented argument lists. Also because of our allocate and
          deallocate options on the tape machine, we end up with some clean, but
          destructive operations.  In order to reduce these burdens to some extent,
          in the TM library we provide two macros to make list creation a little bit
          easier.  We call them 'q' and 'L'.

          <h2>q or [...]</h2>

        <p>
          In Lisp a quoted list is taken as being literal.  However the result of
          modifying a literal is undefined, and often leads to bad results.  Hence provide
          the macro <i>q</i> which returns a quoted list which is not a literal.

          <pre><sample>
              * (q a b c)

              (A B C)
          </sample></pre>

        <p>
          To make it easier to use we have defined a reader macro over brackets.

          <pre><sample>
              * [a b c]

              (A B C)
          </sample></pre>
            

        <h2>L or {...}</h2>

        <p>
        When a form enclosed in parens, ( ... ), is evaluated the head is taken as the
        name of a function, looked up and called.  The list members are also evaluated,
        and then passed as operands to said function.  If we don't want the head treated
        specially, but rather just want to define a list, we can trick the evaluator into
        giving us a list by padding the list with a front item of #'list, which is the
        function to create a list.

        <pre><sample>
            * (list 1 2 (+ 1 2))

            (1 2 3)
        </sample></pre>

        <p>
        We have defined a macro called <i>L</i> that like list, creates a list, but which
        also has some extra functionality.

        <pre><sample>
           * (L 1 2 (+ 1 2))

           (1 2 3)
        </sample></pre>

        <p>
        We also provide a reader macro over braces.

        <pre><sample>
            * { 1 2 (+ 1 2)}

            (1 2 3)
        </sample></pre>

        <p>
        If the apparent function #'o appears inside of a call to #'L, then
        the arguments of the #'o function are included directly in the resulting
        list:

        <pre><sample>
            * (defvar a {1 2 3})

            A
            * (defvar b {4 5 6})

            B
            * {a (o b)}

            ((1 2 3) 4 5 6)
        </sample></pre>
        
        <p>
        Quoted non-literals can also occur within such an <i>L</i> list:

        <pre><sample>
            * {a (o b) [a b]}

            ((1 2 3) 4 5 6 (A B))
            * {a (o b) (o [a b])}

            ((1 2 3) 4 5 6 A B)
        </sample></pre>

        <p>
        <i>L</i> is a little bit like quasiquote turned inside out.  Where
        as the default in quasiquote is to quote items, and a comma operator
        turns that off,  the default in <i>L</i> is to evaluate items, and
        a <i>q</i> operator turns that off.   Quasiquote has an @ marker
        to open up lists, while <i>L</i> has an <i>o</i> operator to open
        up lists.

        <p>
        Note however, inside of a quasiquote we could get in trouble if
        the name of a variable starts with an @ character.  If such a variable
        appears after a comma, quasi quote will consider the variable name
        without the @ sign is to be opened and included.  This is an example
        of where 'in-band signaling' causes us to have to make rules to leave
        values out of our data set (or in this case a character out of variable
        names).

        <p>
        There is no analogous problem with <i>o</i> operator because it appears
        within the function channel.
        
    </section>
  </article>

</body>
</html>
