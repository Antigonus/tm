
----
instead of destructive programing == morphological programming
cells are affected.


---
need to discuss issues of communication between dupped (cue-to) tms.

----
define fill and spill

---

having only one head saves from deallocation conflicts between heads, though
dup changes this and creates an explicit head management / cell problem.

              (cue-to-leftmost tm-dst)
              (d* tm-dst 

notice that there are no heads on cells to be deallocated


---


defmc should have three sections:
parameters, state objects, continuations

----


tms are state

-------
The only true object with no structure, i.e. atom, in contemporary computing is the bit.
All other objects are created from a container of bits.  We implement in hardware
enough concept of container that software can take over from that point.

Primitive objects are structured objects, and the bit, which are provided by hardware.

Programmer composed objects are those that constructed from primitive objects and other
programmer compose objects.

We may define a data abstraction, say A, above which all objects reduce to objects defined
in A0.  In objects in A are then indistinquishable from atoms in the abstractions built
upon A0.  We invoking the software and/or hardware to implemented A.  Such an example
abstraction, is our set of primitive objects.  We may have further or alternative data
abstractions, and even mix these.

In conventional computing a cell that holds a bit is the only cell that is not structured
from other cells.

Similarly we have data allocation abstractions.  A 

object comes from an instance of a structure, so there is a relationship between
data abstraction and allocation abstraction.


The concept of allocation cell then becomes relative to an abstraction.  We say
we can put any object from an abstraction in a cell, but all objects reduce to
primitive objects, and the cells at the primitive 

When an object is constructed of abstract atoms, 

a problem with inclusive bounding addressing is that the last object
may be of differing types, hence if

so the problem with inclusive address bounds, is the bound becomes relative to the
allocation abstraction and the object abstraction.  This is due to our right going
bias in computing.  Where as an exclusive bound does not have this problem,
as all objects structure starting from a base address.

Lisp provides a solution to this problem, as all objects are by reference, and
what we call an allocation for an object on a tape, is actually an allocation
for a reference to the object.  Hence, in Lisp we have another paradigm for
providing inclusive bounds.


---

we do not have tape ends, rather we have the rightmost and leftmost allocated cells,
theoretically, there are no tape ends, only as far as we have allocated.

direction bias, step means one step to the right,  -step is a step to the left

addresses locate cells, not data, cells contain data
(data? items? objects?...)


only one primitive object the bit
all other objects have structure == an internal address space, a virtual memory

object = a bit,  or data that has structure

not keen on the term object ... structured data ...

data bound to type = object

type is a description of the object structure, type name is a property
of the object, and of the structure.




contract, promise ..

errors only for bugs ... continuations for other conditions,  must always be two
branches in a continuation, as otherwise we can't distinguish how we got to the confluence
point.

may -- permission, does imply a probable not equal to 1 event because we don't know if
someone who has permission used it, but may itself only means permission.  To indicate
ap rpobable not equal to 1 event we use the word 'might'.

1. escape boundary algebra  (error algebra etc.)
   note nil is not a list, array etc. rather it represents .. thus to have identity
   we must have one cell.

2. one ended tape is not a limitation due to threading, because we can dup a machine and it
   starts at leftmost, moving in one direction is not a limitation.  Because we implement
   grow, nor is having a finite tape.  Note architectural Turing complete, versus physically.
   Growing and moving eqivalence.

3. memory book,  CAR CDR book
   
CLOS did not allow optional arguments on the generic interface to have defaults.

note the comments at the top of tape-machine.lisp need to be moved.

step *to* a cell

the head is *on* a cell.  A cell is *under* the head.
The tm is at a given cell, means that the tm's head is on the given cell.

rightmost objet is the objet from the rightmost cell.

step a head, moves one cell over, step multiple times possible, so 'step to' makes
sense.  To put the head on a cell without any continuity in stepping, is to
'cue' the head to the cell.  (The head is never said to "move", rather it steps
or is cued.)

step a head *to* a cell, step a tm head *from* a cell
step tm *to* cell, step tm *from* a cell

the cell indicated by a given tm, is the cell the given tm's head is on.

to index a tape machine is to force the head to be on a given cell.

BOT beginning of tape (leftmost)
EOT end of tape (rightmost)

CUH cell under head
OUH object under head

CHP current head position

HCA head cell address
AoCUH
AOH address of head
HA head address

right hand side
left hand side

leftmost left-interior cell-under-head right-interior rightmost
LM LI CUH RI RM

middle= lefthand-side cell-under-head righthand-side

lefthand-side = left-interior or leftmost
righthand-side = right-interior or rightmost

left a direction of potential head motion
right a direction for potnetial head motion

the head may step right or step left.  The had does not *move*, rather it *steps*.

A tape machine can not step, as it is an inanimate object.  Unless in some very
special context the tape machine where the head for another tape machine, but even
then it is probably better to say the head stepped.

To say the tape machine moves, is to say that the tape machine was contained in
once cell, but now it is contained in a different cell.

just as much about providing a vocabulary as providing a generic sequence
interface, in some cases the generic interface is not complete, i.e. we must
know something about the tape implementation to pick the best method to call.
Particularly related to leftward movement of the head.

of course stepping is a type of motion, these are technical terms.

list uses grow to emulate move
array uses move to emulate grow

a little bit of aliasing here ... head of list, versus tape head

we use errors for bug conditions, things that shouldn't have happened had
the code been healthy

first cell = first cell discovered that has a particular property discovered
while stepping.  I.e. first, second, etc is relative to stepping motion.
Then the unqualified first cell is the one under the head, as it is the one
that will first be tested for a given property when stepping.

say 'step'  not 'advance' not 'moved'

cue (not set),  cue *to*

in an interval there is left and right,  
or sometimes var and var-right
on a tape there is leftmost and rightmost,
or sometimes var and var-rightmost

there is no doubt there is a right going bias in computing,  base pointers,
linked lists, etc.  because of this we say, step, not step-right, etc.


nil is not the empty list.  Lisp does not have a symbol for the empty list.
false ->  multvalue unassigned ->  there is a many to one relationship going
into nil,  so there can not be a function going out.  If nil where the empty
list it would have type-of list, and length zero.  However, if we constrain
the type domain just to lists, then map becomes mutual, and we can infer
through this constraing that nil is representing the empty list. ... because
nil does not have type, it can not trigger method specialization in CLOS.


---

need a bind form, with a bind signature that choses what code to run
based on what bind took place.  Only n+1 cases.  A little bit like
case or cond.

(bind (a b c) (1 2) cont-a-b-c cont-a-b cont-a cont-âˆ…)
  
----

exists and all are preferred words for quantification
---

let of lambda form is important,  we only pass state variables created in the
function to continuations, otherwise they get their operands from the enlosing
let -- and often they need them, as these will be the tape-machines

---

tm "holds" ...
tm holds integers .. all objets on the tape machine are to be integers
tm holds objets .. technical definition for the term objet

000
intented to have some formal aspects
e.g. all tms are valid, no such thing as an unitialized ..
inclusive bounds ...

so you must have at least one objet before creating a tape machine,
and to remove the last objet one must delete the machine --- similar
to Lisp lists  (as nil is not a list).

---
tms tend to get burned by operations as most routines move them,
(as they represent the internal state for the routine, which is why
it is usful for continuing an operation, or knowing where one stopped)
so expect to create a lot of them ... (copy)

----

Unless, qualified, 'tape machines' note stated in the plural, is taken to mean a tape
machine which holds tape machines.


----

tape machines can step, which is a kind of motion

hence saying that a tape machine 'holds'  objets is ambiguous, as
hold also means to prevent from moving.

so instead we speak of 'contains'  and 'constituent objets'

a tape machine is a container

-----

the natural number is the basic tape machine,
or at least the basic tape

we should make an natural number tm
---

we move or copy data

we reallocate cells - when a cell is pointed to by a new place it is doubly allocated,
when it is pointed to by a new pointer, and the pointer is changed, it is reallocated,
when it has no pointers it has been deallocated, and will be garbage collected. In
any case it a cell is never moved nor copied.  Its contents can be, but not the cell
itself.

Inside of a virtual memory, say M1 virtualizes M0, a cell in M1 will be data in M0, so
in such a case the nomenclature is context sensitive.

An object is not a cell, rather an object is contents of cell.

data
item
element
member
object

