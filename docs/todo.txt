

2. access lang needs to be finished, also chapter needs to be added
to the manual.

expand access lang

4. need to write mn and m* as repeating m is very inefficient

6. binner is commented out in worker-utilities, due to a change before
the last release

7. right now tm-difference-engine is only linear, need to finish implementation
   tm-line -> tm-difference-engine .. will rename it tm-sums
   (really it sums a finite difference to recover the original sequence)

8. ... need tm on a stream, also the utf8 converters --> tm needs to re

10. should modify #'L, i.e. {},  to recognize repeated symbols and only evaluate
    them once.  This could be done by wrapping the current #'L with a let.

    wonder, .. square brackets to make machines  and curly for lists?
    or square brackets for vectors ...  quote ... really?

11. need to add name spaces for test-hook, and then have (test-all) run everything
independent of the names space, and (test-all 'space) to run only the given name
space

13. removed the affine versions, need to add an affine transform, when
passed a projective machine, turns it into an affine one.  .. the old
affine machine are sitting in scratch

16. unmount of void is a little funny, it is dispatched from type tm-void, but
then must determine how to make various void object ...  perhaps
the fall of the end case should just return nil, should this somehow dispatch
so folks can define their nil sequence cases?

22. #'a need to expand out cont-no-alloc to the two cases rightmost and not-supported
  did this, now want to undo it ... unsuported ops should simply not disptatch, we
  dont' want to implement child interfaces saying 'unsupported' as that presumes
  we know what future child interfaces are going to be

23. add somethign to the manual about functional programming (state machines),  state
variables,  and transactional behavior for tm functions (so that state doesn't change
when state transitions are not taken) .. about region and cell addresses, note
copy to new list doe snot have the problem and it is also transactional

30. with-dups should keep a enganglements list pointer for the bottom of
  the dups stack, and then just pop them all off in one step at the end.
  The current approach is built from existing functions just to get
  the functionality in place.

29. some sort of issue with mount and subspaces ... should descend into subspaces (not leave any tms)

    ...add a manifold machine type, note the comments currently in tm-region.lisp.

32.
  ;; behavior is not transactional, all machines update even when one or more cont-not-supported
  ;; need to check support first
  (defun ∀-entanglements-d◧-0 (tm cont-ok cont-not-supported)

  all api functions should either be transactional or return state for continuing
  .. I don't think we quite have that yet

33. change the quantifiers so that the first parms are optional, the first parm is
   the object, and the second is the machine .. there is something a little funny
   about passing the list into the predicate, as usually we already have the list,
   hence would just like to leave the predicate without parms ... but sometimes
   the list is created with an expression, so then it is useful to have it passed
   in.  Most predicates don't need the list, they just want the read object.
   key parms?


