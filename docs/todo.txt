

2. access lang needs to be finished, also chapter needs to be added
to the manual.

expand access lang

4. need to write mn and m* as repeating m is very inefficient

6. binner is commented out in worker-utilities, due to a change before
the last release

7. right now tm-difference-engine is only linear, need to finish implementation
   tm-line -> tm-difference-engine .. will rename it tm-sums
   (really it sums a finite difference to recover the original sequence)

8. ... need tm on a stream, also the utf8 converters --> tm needs to re

10. should modify #'L, i.e. {},  to recognize repeated symbols and only evaluate
    them once.  This could be done by wrapping the current #'L with a let.

    wonder, .. square brackets to make machines  and curly for lists?
    or square brackets for vectors ...  quote ... really?

11. need to add name spaces for test-hook, and then have (test-all) run everything
independent of the names space, and (test-all 'space) to run only the given name
space. also if one runs load twice all the tests double up.  something should
be done so that only the most recent version plays.

13. removed the affine versions, need to add an affine transform, when
passed a projective machine, turns it into an affine one.  .. the old
affine machine are sitting in scratch

22. no-alloc continuations need to be implemented

23. add somethign to the manual about functional programming (state machines),  state
variables,  and transactional behavior for tm functions (so that state doesn't change
when state transitions are not taken) .. about region and cell addresses, note
copy to new list doe snot have the problem and it is also transactional

29. some sort of issue with mount and subspaces ... should descend into subspaces (not leave any tms)

    ...add a manifold machine type, note the comments currently in tm-region.lisp.

    note doc on subspaces, pulled them out, need to be reimplemented

32.
  ;; behavior is not transactional, all machines update even when one or more cont-not-supported
  ;; need to check support first
  (defun ∀-entanglements-d◧-0 (tm cont-ok cont-not-supported)

  all api functions should either be transactional or return state for continuing
  .. I don't think we quite have that yet

33. change the quantifiers so that the first parms are optional, the first parm is
   the object, and the second is the machine .. there is something a little funny
   about passing the list into the predicate, as usually we already have the list,
   hence would just like to leave the predicate without parms ... but sometimes
   the list is created with an expression, so then it is useful to have it passed
   in.  Most predicates don't need the list, they just want the read object.
   key parms?


35. init should fail if there are unused keys. init functions that 'call-next-method'
  need to renove their keys, so that the more general init can detect unused
  keys.  (wrote remove key, it is in src0)

36. test           + TEST-META-WRAP-0   fails after being run multiple times ...

37. scoped form of mk.  See implementation/status.txt

38. split, split machine in half

39. moved r◧, w◧ from nd-tm to tm. Added some other left of the tape operators, and one
next to the left of tape operators.  Need to propagate these through to the transforms.
Also, do the quantified ops need to be propagated into, at least, the identity transform.

40. breakup/breakout ea-entanglment routines into eather ea-decl or ea-generic

41. nil write on d&parked&length-one -- should make empty be a machine specific routine?

42. esw rightmost continuation should take the instance as an operand

43. cue-leftmost / rightmost names updated to cue◧  and cue◨.   Perhaps c◧ and c◨.
    I don't think we will have 'copy' because that would be w* with a fill.  We
    will have move.  So c might be available.

44. add c-to works with two machines that are entangled, cues one to be at the same
    location as the other.

45. predicate functions should take two continuations,  but what if there is a case
   where something is neither true nor false for a specialization .. perhaps that
   is not salient ..

46. interesting situation in d◧ for ea-definitions.  We would like to enclose a call
   'with-lock-held', but we can't because we must release the lock before calling
   continuations within the 'a' for the spill, and there are multiple continuations.  So..
   instead we acquire the lock, and release it within each contiuation; however
   specializations might have their own continuations that we don't know about.
   We know about ➜ok  and ➜no-alloc, but the others are handled through the
   (o (remove-keys ...))  thing.  We don't know what they are (if they exist at all)
   and thus can not modify them by adding a lock release.  We might provide an
   standard 'always-before' continuation .. and release the lock there.  Anyway,
   need to fix this design.  For now, I'm only providing the continuations known
   for 'a' in src-list (➜ok and ➜no-alloc). 

   ... perhaps what we need is to be able to list multiple keys, followed by a single
   lambda.  keys may appear in more than one list, they execute in order.

   So for a continuation list, in the parameters list:
   {
     :a :b :c  (λ() (release lock)  .. executed when a b or c is present
     :b  (λ() .. executed after the above is executed
     :d (λ() .. runs with lock held
     }

   .. and need an else clause ..  and an any clause

   also need to build in exception handler options, because these are not going
   away in Lisp

   wonder, what of a loop with a continuations call:

      (c◧∀* (entanglements tm)
        (λ(es)
          (call-next-method (tg:weak-pointer-value (r es)) instance ➜) ...

   seems to work



47. looks like we need some fundamental circular structures.  for example, the entanglements
   list would like to be circular.  Yes we will add an affine transform, but might
   be higher performance to have a couple of native circular machines.

48.
   d◧  needs to be epd  'entangle, park, delete'
   a◧  "


49. need to turn #'cant-happen into a function like be that when prins is turned
  on prints a where message and why it isn't supposed to happen

50.  ⟳ needs a max-iteration count continuation option

51. tape length tests for status machines should be based on addresses as that is
faster.

52. clean up ea-parked-active d◧ .. make some of those labeled functions
   generally available, such as collision◧  collision ... need to add the
   compare at the end of test-ts1-4
